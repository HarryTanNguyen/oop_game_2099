FIT 2099 Object-Oriented designs and implementations Assignment 1 design rationale Doors and keys* For doors and keys, we will be implementing this feature using the concept of inheritance. This is because walls, grounds share largely similar features albeit little differences. As such, we will make Grounds the super class and extends Walls, Floors and Doors from it. Walls have unique feature (attribute) of doors that Grounds do not have. Key is implemented as an instance of item class. Doors can be locked and unlocked via Boolean, where presence of a key can flip the Boolean flag. In our concept, each key is specific to one door only. Enemies* Given that an Actor class is currently present, we will simply extend the Enemy types as subclasses (Goons, Grunts, Doctor Maybe and Ninja) from the Actor class given that they all share similar attributes (i.e. hit points, has actions, name). In addition, each enemy class have their own specific characteristics, which we will just implement as methods and attributes.* For Goons, the ability to insult the player at 10% chance is likely to utilize the use of random (to be imported).* For Ninjas, since they only move when player is within a certain range (5 squares within), a collection variable should be made for Ninjas to store the 5 squares within their current location. A check can be launched at each round, checking if playerï¿½s location is in the collection. Random is also used in Ninja to allow generation of 50% chance of stun action. The stun action is launched by the execute function in Action class.*  For player, It is already extended from Actor class. The player class is largely different from all other classes extended from Actor class as this class is controlled by user and has to have relationships with all other extended actor subclasses (such as all the enemy subclasses and Q).* For Q, since it can only wander around and respond to players' interaction, there is not much special attributes to add. However, we are likely to utilize random here to generate random wandering of Q. We will not be allocating  behaviors to Q given that Q does not carry out active actions. However, Q does carry out two possible passive actions,  depending on the interaction with player. Hence, when player finds and interact with Q, we will use select one of  the two possible actions accordingly rather than making a behavior class specific to its actions. * For Doctor Maybe, since he is not going to move at all, in the construction of this character, we can pass in his location as a parameter and store as a static field that cannot be changed. Since his location is locked, doors and keys concept will be applied before player can enter and interact with Doctor Maybe.Rocket Building* For this feature, we will have another class called Rocket specifically meant for rocket building. Rocket class will be extended from the Item class. This class uses the logic of composite aggregation because in order to succeed building the rocket, the player needs all two components of the rocket.* Three objects will be created in total for this class, namely rocket plan, rocket engine and rocket body. The latter two is utilized in the composite aggregation idea. For rocket plan, it's assigned to Q at its initialization. * Launch pad is a feature in the rocket building concept as well, but it will be implemented as a specific location rather than a Rocket object.BehaviorWe also create "InsultBehavior" and "stunBehaviour" classes. They implement the Action Factory class. Therefore, Goon can insult player and Ninja can stun player.*Launch RocketTo move to mar(moon base), we need add Move Actor Action to Rocket. Therefore, when player is standing in the rocket they can move to anothermap. In the moon base i also put one rocket in, it looks like rocket moving from earth to moon base. For the rocket in the moonbase we add a move actor action that help player can move back to earth*Spacesuit and moving around moon base add Spacesuit in earth then in the gameplayer inherited from player, we need to check where player is standing. If player stands in the moon basewe check whether player has suit or not. if player doesnt have space suit only can choose 2 option: staying in the rocket or return back to earth. Otherwise they can moving around the moon base as long as having enough oxygen.*Oxygen and oxygen dispenser-In GamePlayer class we also check oxygen and and decrease the oxygen every turn. If there is no oxygen left, player automatically return player back to earth in the location of rocket pad. Also we check the oxygen tank in player inventory. if player has a oxygen tank we will add 10 oxygento oxygen supply of player-For oxygen dispenser, it is the furniture item, we also add "produce oxygen tank action" to oxygen dispenser. "Produce oxygen tank action" checks whether oxygen dispenser is producing oxygen tank. it also check whether player is standing in the another oxygen tank. After two times interact with oxygen dispenser, create a oxygen tank and add to inventory of player*End game optionWe have 3 options to end game. One is player want to exit. We created a "Exit game action". When player choose this option, We break the game loop in World Game which is inherited from World class. the seccond option is player loose the game, so in the run function in World game, we check the hit pointof player and break the loop and end game if hit point <0. The last option is end game. In Run method in World game we check whether player in standing inearth and has final boss body in inventory. If so we break the loop and print the message to notify they won the game. 